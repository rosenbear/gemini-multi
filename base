<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brush Studio App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            overscroll-behavior: none;
            touch-action: none;
        }
        .canvas-bg {
            background-color: #ffffff;
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .studio-canvas-container {
            background-color: white;
            border: 1px solid #e5e7eb;
            cursor: crosshair;
        }
        /* Custom scrollbar for the sidebar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -6px;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }
        /* Swatch Styles */
        .swatch {
            transition: transform 0.1s, border-color 0.1s;
        }
        .swatch.active {
            transform: scale(1.1);
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body class="bg-gray-100 h-screen w-screen flex overflow-hidden font-sans text-gray-800">

    <!-- Sidebar / Tools -->
    <div class="w-96 flex-shrink-0 bg-white shadow-lg flex flex-col h-full z-10 border-r border-gray-200">
        <!-- Header -->
        <div class="p-4 border-b border-gray-200 bg-gray-50">
            <h1 class="text-xl font-bold text-gray-800 mb-1"><i class="fas fa-paint-brush mr-2 text-blue-500"></i>Brush Studio</h1>
            <p class="text-xs text-gray-500">Design your own brush tips</p>
        </div>

        <!-- Main Controls -->
        <div class="p-4 grid grid-cols-2 gap-2 border-b border-gray-200">
            <button id="btn-brush" class="flex items-center justify-center py-2 px-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition active-tool" onclick="setTool('brush')">
                <i class="fas fa-pen mr-2"></i> Brush
            </button>
            <button id="btn-eraser" class="flex items-center justify-center py-2 px-3 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition" onclick="setTool('eraser')">
                <i class="fas fa-eraser mr-2"></i> Eraser
            </button>
            
            <div class="col-span-2 mt-2">
                <label class="text-xs font-bold text-gray-500 uppercase">Brush Size: <span id="size-display">40</span>px</label>
                <input type="range" id="main-brush-size" min="5" max="150" value="40" class="w-full mt-1 appearance-none bg-transparent">
            </div>

            <div class="col-span-2 mt-1">
                <label class="text-xs font-bold text-gray-500 uppercase">Spacing: <span id="spacing-display">5</span>%</label>
                <input type="range" id="brush-spacing" min="2" max="25" value="5" class="w-full mt-1 appearance-none bg-transparent">
            </div>

            <div class="col-span-2 mt-1">
                <label class="text-xs font-bold text-gray-500 uppercase">Flow: <span id="flow-display">0</span> stamps/sec</label>
                <input type="range" id="brush-flow" min="0" max="200" step="0.1" value="0" class="w-full mt-1 appearance-none bg-transparent">
            </div>

            <button onclick="undo()" class="col-span-2 mt-2 flex items-center justify-center py-2 px-3 bg-gray-100 border border-gray-300 text-gray-700 rounded hover:bg-gray-200 transition">
                <i class="fas fa-undo mr-2"></i> Undo
            </button>
            <button onclick="clearAll()" class="col-span-2 mt-1 flex items-center justify-center py-1 px-3 text-red-500 text-sm hover:text-red-700 transition">
                <i class="fas fa-trash-alt mr-2"></i> Clear Canvas
            </button>
        </div>

        <!-- Studios List -->
        <div class="flex-1 overflow-y-auto p-4 bg-gray-50">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-sm font-bold text-gray-600 uppercase">Active Studios (<span id="studio-count">1</span>/5)</h2>
            </div>
            
            <div id="studios-container" class="grid grid-cols-2 gap-2">
                <!-- Studio items will be injected here -->
            </div>
            
            <button id="add-studio-btn" onclick="addStudio()" class="w-full mt-4 py-3 border-2 border-dashed border-gray-300 rounded-lg text-gray-400 hover:border-blue-400 hover:text-blue-500 transition flex items-center justify-center">
                <i class="fas fa-plus mr-2"></i> Add Brush Studio
            </button>
        </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="flex-1 relative bg-gray-200 h-full flex flex-col">
        <div class="absolute inset-4 bg-white shadow-sm rounded-lg overflow-hidden cursor-crosshair canvas-bg" id="canvas-wrapper">
            
            <canvas id="main-canvas"></canvas>

            <!-- Value Swatches UI -->
            <div class="absolute top-4 left-4 flex flex-col gap-2 p-2 bg-white/90 backdrop-blur rounded-lg shadow border border-gray-200 z-20">
                <div class="text-[10px] font-bold text-gray-400 uppercase text-center mb-1">Values</div>
                
                <div class="flex gap-2">
                    <!-- Swatch 1 (Dark) -->
                    <div class="relative group">
                        <div id="swatch-1" class="swatch w-10 h-10 rounded border-2 border-white shadow cursor-pointer active" onclick="openValueSlider(1)"></div>
                        <span class="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500 font-bold">1</span>
                    </div>

                    <!-- Swatch 2 (Medium) -->
                    <div class="relative group">
                        <div id="swatch-2" class="swatch w-10 h-10 rounded border-2 border-white shadow cursor-pointer" onclick="openValueSlider(2)"></div>
                        <span class="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500 font-bold">2</span>
                    </div>

                    <!-- Swatch 3 (Light) -->
                    <div class="relative group">
                        <div id="swatch-3" class="swatch w-10 h-10 rounded border-2 border-white shadow cursor-pointer" onclick="openValueSlider(3)"></div>
                        <span class="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500 font-bold">3</span>
                    </div>
                </div>
            </div>

            <!-- Value Adjustment Slider Popup (Hidden by default) -->
            <div id="value-slider-popup" class="hidden absolute top-24 left-4 p-3 bg-white shadow-xl rounded-lg border border-gray-200 z-30 w-48">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-gray-600">Adjust Value <span id="popup-swatch-id">#1</span></span>
                    <button onclick="closeValueSlider()" class="text-gray-400 hover:text-gray-600"><i class="fas fa-times"></i></button>
                </div>
                <input type="range" id="popup-slider" min="0" max="255" class="w-full">
            </div>

        </div>
        <div class="absolute bottom-6 right-6 bg-white/90 backdrop-blur px-3 py-1 rounded-full shadow text-xs text-gray-500 pointer-events-none">
            Canvas Active
        </div>
    </div>

    <!-- Template for a Studio Card (Hidden) -->
    <template id="studio-template">
        <div class="studio-card bg-white p-2 rounded-lg shadow-sm border border-gray-200 relative group transition-all duration-200 hover:shadow-md">
            <div class="flex justify-between items-start mb-1">
                <span class="text-[10px] font-bold text-gray-500 studio-label uppercase tracking-wider">Studio #1</span>
                <div class="flex gap-1">
                    <button class="clear-studio-btn text-gray-400 hover:text-red-500 p-0.5" title="Clear Studio">
                        <i class="fas fa-trash-alt text-[10px]"></i>
                    </button>
                    <button class="remove-studio-btn text-gray-300 hover:text-red-500 p-0.5 hidden" title="Remove Studio">
                        <i class="fas fa-times text-[10px]"></i>
                    </button>
                </div>
            </div>
            
            <!-- Drawing Area for Studio -->
            <div class="relative w-full aspect-square mb-2 studio-canvas-container rounded overflow-hidden">
                <canvas class="studio-canvas absolute inset-0 w-full h-full"></canvas>
                <!-- Helper text, disappears on draw -->
                <div class="pointer-events-none absolute inset-0 flex items-center justify-center text-gray-300 text-[10px] italic empty-hint">
                    Draw
                </div>
            </div>

            <!-- Controls -->
            <div>
                <div class="flex justify-between text-[10px] text-gray-500 mb-0.5">
                    <span>Prob.</span>
                    <span class="prob-display">100%</span>
                </div>
                <input type="range" class="prob-slider w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="100" value="50">
            </div>
            
            <!-- Add Button inside card as requested -->
            <button class="add-linked-btn absolute -right-2 top-1/2 transform -translate-y-1/2 w-5 h-5 bg-blue-500 text-white rounded-full shadow hover:bg-blue-600 flex items-center justify-center z-10 hidden border-2 border-white" title="Open another Studio">
                <i class="fas fa-plus text-[10px]"></i>
            </button>
        </div>
    </template>

    <script>
        // --- State Management ---
        const state = {
            tool: 'brush', // 'brush' or 'eraser'
            isDrawingMain: false,
            mainBrushSize: 40,
            brushSpacing: 5, // percentage
            flowRate: 0, // stamps per second
            flowInterval: null,
            studios: [], 
            history: [],
            historyStep: -1,
            maxStudios: 6,
            values: {
                1: 30,  // Dark
                2: 128, // Medium
                3: 220  // Light
            },
            activeValueIndex: 1, // 1, 2, or 3
            editingValueIndex: null
        };

        // --- DOM Elements ---
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const studiosContainer = document.getElementById('studios-container');
        const studioTemplate = document.getElementById('studio-template');
        const addStudioMainBtn = document.getElementById('add-studio-btn');
        const sizeDisplay = document.getElementById('size-display');
        const sizeSlider = document.getElementById('main-brush-size');
        const spacingDisplay = document.getElementById('spacing-display');
        const spacingSlider = document.getElementById('brush-spacing');
        const flowDisplay = document.getElementById('flow-display');
        const flowSlider = document.getElementById('brush-flow');
        const popupSlider = document.getElementById('popup-slider');
        const popup = document.getElementById('value-slider-popup');

        // Helper Canvas for tinting brushes
        const tintCanvas = document.createElement('canvas');
        const tintCtx = tintCanvas.getContext('2d', { willReadFrequently: true });

        // --- ID Map System ---
        // Hidden canvas to track which pixel belongs to which Value ID
        const idCanvas = document.createElement('canvas');
        const idCtx = idCanvas.getContext('2d', { willReadFrequently: true });

        // --- Initialization ---
        function init() {
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Initial Studio
            addStudio(true); 

            // Events for Main Canvas
            mainCanvas.addEventListener('mousedown', startMainDraw);
            mainCanvas.addEventListener('mousemove', drawMain);
            window.addEventListener('mouseup', stopMainDraw);
            
            // Touch support
            mainCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startMainDraw(e.touches[0]);
            }, { passive: false });
            mainCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                drawMain(e.touches[0]);
            }, { passive: false });
            window.addEventListener('touchend', stopMainDraw);

            // Brush Controls
            sizeSlider.addEventListener('input', (e) => {
                state.mainBrushSize = parseInt(e.target.value);
                sizeDisplay.textContent = state.mainBrushSize;
            });

            spacingSlider.addEventListener('input', (e) => {
                state.brushSpacing = parseInt(e.target.value);
                spacingDisplay.textContent = state.brushSpacing;
            });

            flowSlider.addEventListener('input', (e) => {
                state.flowRate = parseFloat(e.target.value);
                flowDisplay.textContent = state.flowRate;
            });

            // Keyboard Shortcuts
            window.addEventListener('keydown', (e) => {
                if (['1', '2', '3'].includes(e.key)) {
                    selectValue(parseInt(e.key));
                }
            });

            // Value Slider Logic
            popupSlider.addEventListener('input', (e) => {
                if (state.editingValueIndex) {
                    let newVal = parseInt(e.target.value);
                    const idx = state.editingValueIndex;
                    const buffer = 8; // Buffer to keep values distinct

                    // Constraint Logic: Stop slider before overlapping neighbors
                    if (idx === 1) {
                        // 1 must stay below 2
                        const maxLimit = state.values[2] - buffer;
                        if (newVal > maxLimit) newVal = maxLimit;
                    } else if (idx === 2) {
                        // 2 must stay between 1 and 3
                        const minLimit = state.values[1] + buffer;
                        const maxLimit = state.values[3] - buffer;
                        if (newVal < minLimit) newVal = minLimit;
                        if (newVal > maxLimit) newVal = maxLimit;
                    } else if (idx === 3) {
                        // 3 must stay above 2
                        const minLimit = state.values[2] + buffer;
                        if (newVal < minLimit) newVal = minLimit;
                    }

                    // Force the slider UI to respect the clamped value
                    if (parseInt(e.target.value) !== newVal) {
                        e.target.value = newVal;
                    }

                    updateValue(state.editingValueIndex, newVal);
                }
            });
            popupSlider.addEventListener('change', () => {
                saveState();
            });

            updateSwatchUI();
            saveState(); // Initial state
        }

        // --- Canvas Resizing ---

        function resizeCanvases() {
            const rect = canvasWrapper.getBoundingClientRect();
            
            // Save contents
            const tempMain = document.createElement('canvas');
            const tempId = document.createElement('canvas');
            tempMain.width = mainCanvas.width;
            tempMain.height = mainCanvas.height;
            tempId.width = idCanvas.width;
            tempId.height = idCanvas.height;
            
            if(mainCanvas.width > 0) {
                tempMain.getContext('2d').drawImage(mainCanvas, 0, 0);
                tempId.getContext('2d').drawImage(idCanvas, 0, 0);
            }

            // Resize
            mainCanvas.width = rect.width;
            mainCanvas.height = rect.height;
            idCanvas.width = rect.width;
            idCanvas.height = rect.height;

            // Restore
            if (tempMain.width > 0) {
                 mainCtx.drawImage(tempMain, 0, 0);
                 idCtx.drawImage(tempId, 0, 0);
            } else {
                // Fill white on first init
                mainCtx.fillStyle = '#ffffff';
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                // Clear ID canvas (transparent)
                idCtx.clearRect(0, 0, idCanvas.width, idCanvas.height);
            }
        }


        // --- Value System Logic ---

        function selectValue(index) {
            state.activeValueIndex = index;
            updateSwatchUI();
            closeValueSlider();
        }

        function updateSwatchUI() {
            for (let i = 1; i <= 3; i++) {
                const el = document.getElementById(`swatch-${i}`);
                const val = state.values[i];
                el.style.backgroundColor = `rgb(${val}, ${val}, ${val})`;
                
                if (i === state.activeValueIndex) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            }
        }

        function openValueSlider(index) {
            state.activeValueIndex = index;
            state.editingValueIndex = index;
            updateSwatchUI();
            popup.classList.remove('hidden');
            document.getElementById('popup-swatch-id').textContent = `#${index}`;
            popupSlider.value = state.values[index];
        }

        function closeValueSlider() {
            popup.classList.add('hidden');
            state.editingValueIndex = null;
        }

        // --- UPDATE PIXELS based on ID Map ---
        function updateValue(index, newValue) {
            const oldValue = state.values[index];
            if (oldValue === newValue) return;

            state.values[index] = newValue;
            
            // 1. Get Visual Data
            const imgData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
            const data = imgData.data;

            // 2. Get ID Map Data
            const idMap = idCtx.getImageData(0, 0, idCanvas.width, idCanvas.height).data;

            // 3. Scan and Replace
            for (let i = 0; i < data.length; i += 4) {
                // Check ID Map
                const r = idMap[i];   // ID 1
                const g = idMap[i+1]; // ID 2
                const b = idMap[i+2]; // ID 3
                // Alpha of the ID stroke (tells us how much this pixel belongs to the group)
                const idAlpha = idMap[i+3] / 255; 

                // Is this pixel primarily owned by the current Index?
                let isMatch = false;
                if (index === 1 && r > g && r > b) isMatch = true;
                if (index === 2 && g > r && g > b) isMatch = true;
                if (index === 3 && b > r && b > g) isMatch = true;

                if (isMatch && idAlpha > 0) {
                    // It's a match! We need to recolor it.
                    // But we must preserve the visual alpha/blending relative to white.
                    // Simple approach: The visual pixel is some shade of gray. 
                    // We assume it's blended with white.
                    // Current Pixel Intensity `v`
                    // Target Intensity should be shifted by difference (New - Old).
                    // But scaled by `idAlpha` so we handle edges gracefully? 
                    // Actually, simpler: Recalculate based on white BG.
                    
                    // Let's use the ID Alpha as the "Opacity" of the stroke
                    // NewPixel = (1 - idAlpha) * 255 + idAlpha * NewColor
                    // This creates a perfect reconstruction.
                    
                    const newPixelVal = (1 - idAlpha) * 255 + idAlpha * newValue;
                    
                    data[i] = newPixelVal;
                    data[i+1] = newPixelVal;
                    data[i+2] = newPixelVal;
                }
            }

            mainCtx.putImageData(imgData, 0, 0);
            updateSwatchUI();
        }

        // --- Studio System ---
        function addStudio(isFirst = false) {
            if (state.studios.length >= state.maxStudios) return;

            const id = Date.now() + Math.random();
            const clone = studioTemplate.content.cloneNode(true);
            const card = clone.querySelector('.studio-card');
            const canvas = clone.querySelector('.studio-canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const slider = clone.querySelector('.prob-slider');
            const probDisplay = clone.querySelector('.prob-display');
            const removeBtn = clone.querySelector('.remove-studio-btn');
            const clearBtn = clone.querySelector('.clear-studio-btn');
            const addLinkedBtn = clone.querySelector('.add-linked-btn');
            const hint = clone.querySelector('.empty-hint');
            const label = clone.querySelector('.studio-label');

            canvas.width = 150;
            canvas.height = 150;

            const studioObj = {
                id,
                card,
                canvas,
                ctx,
                slider,
                probDisplay,
                weight: 50,
                isEmpty: true 
            };

            if (isFirst) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(75, 75, 30, 0, Math.PI * 2);
                ctx.fill();
                hint.style.display = 'none';
                studioObj.weight = 100;
                slider.value = 100;
                studioObj.isEmpty = false;
            }

            state.studios.push(studioObj);

            let isDrawingStudio = false;
            
            function drawInStudio(x, y) {
                ctx.lineWidth = 15;
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'black';
                
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
                hint.style.display = 'none';
                studioObj.isEmpty = false; 
            }

            const getStudioPos = (e, cvs) => {
                const rect = cvs.getBoundingClientRect();
                const scaleX = cvs.width / rect.width;
                const scaleY = cvs.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            };

            canvas.addEventListener('mousedown', (e) => {
                isDrawingStudio = true;
                ctx.beginPath();
                const pos = getStudioPos(e, canvas);
                drawInStudio(pos.x, pos.y);
            });
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawingStudio) return;
                const pos = getStudioPos(e, canvas);
                drawInStudio(pos.x, pos.y);
            });
            window.addEventListener('mouseup', () => {
                isDrawingStudio = false;
                ctx.beginPath();
            });

            slider.addEventListener('input', (e) => {
                studioObj.weight = parseInt(e.target.value);
                updateProbabilities();
            });

            clearBtn.addEventListener('click', () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                hint.style.display = 'flex';
                studioObj.isEmpty = true; 
            });

            removeBtn.addEventListener('click', () => {
                removeStudio(id);
            });

            addLinkedBtn.addEventListener('click', () => {
                addStudio();
            });

            studiosContainer.appendChild(card);
            updateUI();
            updateProbabilities();
        }

        function removeStudio(id) {
            const index = state.studios.findIndex(s => s.id === id);
            if (index > -1) {
                state.studios[index].card.remove();
                state.studios.splice(index, 1);
                updateUI();
                updateProbabilities();
            }
        }

        function updateUI() {
            document.getElementById('studio-count').textContent = state.studios.length;
            state.studios.forEach((s, index) => {
                s.card.querySelector('.studio-label').textContent = `Studio #${index + 1}`;
                const removeBtn = s.card.querySelector('.remove-studio-btn');
                if (state.studios.length > 1) removeBtn.classList.remove('hidden');
                else removeBtn.classList.add('hidden');
                const addBtn = s.card.querySelector('.add-linked-btn');
                if (state.studios.length < state.maxStudios) addBtn.classList.remove('hidden');
                else addBtn.classList.add('hidden');
            });
            if (state.studios.length >= state.maxStudios) addStudioMainBtn.style.display = 'none';
            else addStudioMainBtn.style.display = 'flex';
        }

        function updateProbabilities() {
            const totalWeight = state.studios.reduce((sum, s) => sum + s.weight, 0);
            state.studios.forEach(s => {
                let percent = 0;
                if (totalWeight > 0) percent = Math.round((s.weight / totalWeight) * 100);
                s.probDisplay.textContent = `${percent}%`;
            });
        }

        // --- Main Drawing Logic ---

        let lastPos = { x: 0, y: 0 };

        function getMainPos(e) {
            const clientX = e.clientX || e.touches?.[0]?.clientX;
            const clientY = e.clientY || e.touches?.[0]?.clientY;
            const rect = mainCanvas.getBoundingClientRect();
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startMainDraw(e) {
            state.isDrawingMain = true;
            lastPos = getMainPos(e);
            drawStamp(lastPos.x, lastPos.y);

            if (state.flowRate > 0) {
                clearInterval(state.flowInterval);
                const intervalTime = 1000 / state.flowRate;
                state.flowInterval = setInterval(() => {
                    if (state.isDrawingMain) drawStamp(lastPos.x, lastPos.y);
                }, intervalTime);
            }
        }

        function drawMain(e) {
            if (!state.isDrawingMain) return;
            const currentPos = getMainPos(e);
            
            if (state.flowRate > 0) {
                lastPos = currentPos;
                return;
            }

            const dist = Math.hypot(currentPos.x - lastPos.x, currentPos.y - lastPos.y);
            const step = Math.max(1, state.mainBrushSize * (state.brushSpacing / 100));

            for (let i = 0; i < dist; i += step) {
                const cx = lastPos.x + (currentPos.x - lastPos.x) * (i / dist);
                const cy = lastPos.y + (currentPos.y - lastPos.y) * (i / dist);
                drawStamp(cx, cy);
            }
            lastPos = currentPos;
        }

        function stopMainDraw() {
            if (state.isDrawingMain) {
                state.isDrawingMain = false;
                clearInterval(state.flowInterval);
                saveState();
            }
        }

        function drawStamp(x, y) {
            const size = state.mainBrushSize;
            
            const allEmpty = state.studios.every(s => s.isEmpty);
            const activeGrayVal = state.values[state.activeValueIndex];
            const activeColor = `rgb(${activeGrayVal}, ${activeGrayVal}, ${activeGrayVal})`;
            
            // Map ID to Color Channel (R, G, B)
            const idColor = state.activeValueIndex === 1 ? 'rgb(255,0,0)' 
                          : state.activeValueIndex === 2 ? 'rgb(0,255,0)' 
                          : 'rgb(0,0,255)';

            // Prepare the Stamp Image
            let sourceCanvas = null;
            let studio = null;

            if (allEmpty) {
                // Generate a circle stamp on the fly
                if (tintCanvas.width !== size || tintCanvas.height !== size) {
                    tintCanvas.width = size; tintCanvas.height = size;
                }
                tintCtx.clearRect(0,0,size,size);
                tintCtx.beginPath();
                tintCtx.arc(size/2, size/2, size/2, 0, Math.PI*2);
                tintCtx.fillStyle = 'black'; 
                tintCtx.fill();
                sourceCanvas = tintCanvas;
            } else {
                studio = pickRandomStudio();
                if(studio) sourceCanvas = studio.canvas;
            }

            if (!sourceCanvas) return;

            // --- Drawing Logic ---
            
            if (state.tool === 'eraser') {
                // Erase from Main Canvas
                mainCtx.globalCompositeOperation = 'destination-out';
                mainCtx.drawImage(sourceCanvas, x - size/2, y - size/2, size, size);
                mainCtx.globalCompositeOperation = 'source-over';
                
                // Erase from ID Canvas (Clear ownership)
                idCtx.globalCompositeOperation = 'destination-out';
                idCtx.drawImage(sourceCanvas, x - size/2, y - size/2, size, size);
                idCtx.globalCompositeOperation = 'source-over';

            } else {
                // Brush: Draw normally to Main Canvas
                // 1. Prepare visual stamp
                if (tintCanvas.width !== size || tintCanvas.height !== size) {
                    tintCanvas.width = size; tintCanvas.height = size;
                }
                tintCtx.clearRect(0, 0, size, size);
                tintCtx.globalCompositeOperation = 'source-over';
                tintCtx.drawImage(sourceCanvas, 0, 0, size, size);
                tintCtx.globalCompositeOperation = 'source-in';
                tintCtx.fillStyle = activeColor;
                tintCtx.fillRect(0, 0, size, size);
                
                mainCtx.globalCompositeOperation = 'source-over';
                mainCtx.drawImage(tintCanvas, x - size/2, y - size/2);

                // 2. Draw ID stamp to ID Canvas
                tintCtx.globalCompositeOperation = 'source-over';
                tintCtx.clearRect(0, 0, size, size);
                tintCtx.drawImage(sourceCanvas, 0, 0, size, size);
                tintCtx.globalCompositeOperation = 'source-in';
                tintCtx.fillStyle = idColor;
                tintCtx.fillRect(0, 0, size, size);
                
                // Note: We use source-over for ID map so new strokes claim ownership
                idCtx.globalCompositeOperation = 'source-over';
                idCtx.drawImage(tintCanvas, x - size/2, y - size/2);
            }
        }

        function pickRandomStudio() {
            const totalWeight = state.studios.reduce((sum, s) => sum + s.weight, 0);
            if (totalWeight === 0) return state.studios[0]; 

            let random = Math.random() * totalWeight;
            for (const studio of state.studios) {
                if (random < studio.weight) return studio;
                random -= studio.weight;
            }
            return state.studios[state.studios.length - 1];
        }

        // --- Tools & Undo ---

        function setTool(t) {
            state.tool = t;
            const btnBrush = document.getElementById('btn-brush');
            const btnEraser = document.getElementById('btn-eraser');
            
            if (t === 'brush') {
                btnBrush.className = "flex items-center justify-center py-2 px-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition active-tool";
                btnEraser.className = "flex items-center justify-center py-2 px-3 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition";
            } else {
                btnBrush.className = "flex items-center justify-center py-2 px-3 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition";
                btnEraser.className = "flex items-center justify-center py-2 px-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition active-tool";
            }
        }

        function saveState() {
            // Save state of both canvases
            const frame = {
                main: mainCanvas.toDataURL(),
                id: idCanvas.toDataURL()
            };
            
            if (state.historyStep < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyStep + 1);
            }
            
            state.history.push(frame);
            if (state.history.length > 20) state.history.shift();
            else state.historyStep++;
        }

        function undo() {
            if (state.historyStep > 0) {
                state.historyStep--;
                const frame = state.history[state.historyStep];
                
                const imgMain = new Image();
                const imgId = new Image();
                
                let loaded = 0;
                const done = () => {
                    loaded++;
                    if (loaded === 2) {
                        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                        mainCtx.drawImage(imgMain, 0, 0);
                        idCtx.clearRect(0, 0, idCanvas.width, idCanvas.height);
                        idCtx.drawImage(imgId, 0, 0);
                    }
                };

                imgMain.onload = done;
                imgId.onload = done;
                
                imgMain.src = frame.main;
                imgId.src = frame.id;
            }
        }

        function clearAll() {
            mainCtx.fillStyle = 'white';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
            idCtx.clearRect(0, 0, idCanvas.width, idCanvas.height);
            saveState();
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
